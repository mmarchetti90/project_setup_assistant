#!/usr/bin/env python3"""This script will plot peaks from atacseqInput is a data manifest, a tsv file with following lines:- "annotation	</path/to/annotation/gtf" to declare GTF file for annotation;- "peaks </path/to/peaks/differential/analysis> to declare file with differential peaks coordinates and annotation;- "sample <sample_group> </path/to/replicate/of/sample/group/bed>" to declare a bed file belonging to a specific sample group- "gene <gene_id or gene_name>" to declare a gene to be plottedN.B. Samples belonging to the same group will be averaged."""### ---------------------------------------- ###def parse_args():        # Parse manifest    data_manifest_file = argv[argv.index('--data_manifest') + 1]        samples_path = {}    genes_list = []        with open(data_manifest_file) as info:                for line in info:                        info = line.replace('\n', '').split('\t')                        if info[0] == 'annotation':                                annotation_path = info[1]                        elif info[0] == 'peaks':                                peaks_path = info[1]                        elif info[0] == 'sample':                                try:                                        samples_path[info[1]].append(info[2])                                    except:                                        samples_path[info[1]] = [info[2]]                        elif info[0] == 'gene':                                genes_list.append(info[1])                        else:                                pass        # Genes region extension    if '--gene_ext' in argv:                gene_extension = int(argv[argv.index('--gene_ext') + 1])        else:                gene_extension = 1000    # Peaks significance    if '--p_thr' in argv:                p_thr = float(argv[argv.index('--p_thr') + 1])        else:                p_thr = 0.05        return annotation_path, peaks_path, samples_path, genes_list, gene_extension, p_thr### ---------------------------------------- ###def get_gene_structure(ann, gn):        # Subset for gene of interest    ann = ann.loc[[f'gene_id "{gn}"' in attr or f'gene_name "{gn}"' in attr for attr in ann.attributes.values], ]        # Get gene coords    coords = ann.loc[ann.feature == 'gene', ['chrom', 'start', 'end']].values[0]        # Keep only info for gene structure (exons and UTRs)    ann = ann.loc[ann.feature.isin(['five_prime_utr', 'three_prime_utr', 'exon'])]        return coords, ann### ---------------------------------------- ###def get_gene_coverage(coords, s_p):        coverages = {}    for group, samples in s_p.items():                group_coverage = np.zeros((len(samples), coords[2] - coords[1] + 1))                for s_num,sample in enumerate(samples):                        # Load sample coverage            col_dtypes = {0 : str, 1 : int, 2 : int, 3 : float}            sample_coverage = pd.read_csv(sample, sep='\t', header=None, dtype=col_dtypes)            sample_coverage.columns = ['chrom', 'start', 'end', 'coverage']                        # Filter for coords            sample_coverage = sample_coverage.loc[(sample_coverage.chrom == str(coords[0])) &                                                  (sample_coverage.start >= coords[1]) &                                                  (sample_coverage.end <= coords[2]),]                        # Fill group_coverage            for row_n, row in sample_coverage.iterrows():                                chrom, start, end, cov = row                group_coverage[s_num, int(start) - coords[1] : int(end) - coords[1] + 1] = cov        coverages[group] = group_coverage.copy()        return coverages### ---------------------------------------- ###def plot_individual_coverage_data(gn, coords, struct, pks, covs, p_thr=0.05):        figsize = (10, sum([len(c) for c in covs.values()]) + 2)    height_ratios = [2 for _ in range(sum([len(c) for c in covs.values()]))] + [0.55, 0.55]    xmin, xmax = coords[1:]    ymin, ymax = 0, max([c.max() for c in covs.values()])    fig, axs = plt.subplots(nrows=sum([len(c) for c in covs.values()]) + 2,                            ncols=1,                            figsize=figsize,                            height_ratios=height_ratios,                            sharex=True)    plt.xlim(xmin, xmax)    # Plot coverage for each group    group_colors = ['red', 'blue']        n = 0    for n_group, ((group, group_cov), color) in enumerate(zip(covs.items(), group_colors)):                for n_sample, sample_cov in enumerate(group_cov):                    axs[n].fill_between(x=np.arange(coords[1], coords[2] + 1, 1),                                y1=np.zeros(coords[2] - coords[1] + 1),                                y2=sample_cov,                                color=color,                                lw=0)                        axs[n].plot(np.arange(coords[1], coords[2] + 1, 1),                        sample_cov,                        c=color,                        lw=1,                        marker=None,                        alpha=0.5)                        axs[n].set_ylim(ymin, ymax)            axs[n].set_title(f'{group} {n_sample+1}', loc='center')            axs[n].axis('off')                        n += 1    # Plot peaks    if pks.shape[0] > 0:                for pk_n,pk in pks.iterrows():                        axs[n].plot(range(pk.start, pk.end + 1, 1),                        np.zeros(pk.end - pk.start + 1),                        c='black',                        lw=8)                        axs[n].plot(range(pk.start, pk.end + 1, 1),                        np.zeros(pk.end - pk.start + 1),                        c='green' if pk.padj < p_thr else 'lightgray',                        lw=6)            axs[n].axis('off')        else:                axs[n].axis('off')    # Plot gene body    n += 1    intron_size = 1    axs[n].plot([struct.start.min(), struct.end.max() + 1],                [0, 0],                c='black',                lw=intron_size)    # Plot gene elements    utr_size = 5    exon_size = 8    for _,element in struct.iterrows():                if element.feature == 'exon':                        axs[n].plot([element.start, element.end + 1],                        [0, 0],                        c='black',                        lw=exon_size)        else:                        axs[n].plot([element.start, element.end + 1],                        [0, 0],                        c='black',                        lw=utr_size)    # Plot arrows indicating direction of gene    strand = struct.strand.values[0]    arrows_x = np.linspace(struct.start.min(), struct.end.max() + 1, 30)    if strand == '-' :                arrows_x = arrows_x[::-1]            #axs[n].plot(arrows_x,    #            np.zeros(arrows_x.shape[0]),    #            c='black',    #            lw=0,    #            marker='>' if strand == '+' else '<',    #            markersize=3)    #axs[n].plot(arrows_x,    #            np.zeros(arrows_x.shape[0]),    #            c='white',    #            lw=0,    #            marker='>' if strand == '+' else '<',    #            markersize=2)    axs[n].plot(arrows_x,                np.zeros(arrows_x.shape[0]),                c='black',                lw=0,                marker='4' if strand == '+' else '3',                markersize=8)    axs[n].axis('off')    plt.tight_layout()    plt.savefig(f'{gene}_profile.png', dpi=600)    plt.close()### ---------------------------------------- ###def plot_averaged_coverage_data(gn, coords, struct, pks, covs, p_thr=0.05):        # Collapse groups to median values    for key in covs.keys():                covs[key] = np.median(covs[key], axis=0)        figsize = (10, len(covs) + 2)    height_ratios = [2 for _ in range(len(covs))] + [0.55, 0.55]    xmin, xmax = coords[1:]    ymin, ymax = 0, max([max(c) for c in covs.values()])    fig, axs = plt.subplots(nrows=len(covs) + 2,                            ncols=1,                            figsize=figsize,                            height_ratios=height_ratios,                            sharex=True)    plt.xlim(xmin, xmax)    # Plot coverage for each group    group_colors = ['red', 'blue']    for n, ((group, group_cov), color) in enumerate(zip(covs.items(), group_colors)):                axs[n].fill_between(x=np.arange(coords[1], coords[2] + 1, 1),                            y1=np.zeros(coords[2] - coords[1] + 1),                            y2=group_cov,                            color=color,                            lw=0)                axs[n].plot(np.arange(coords[1], coords[2] + 1, 1),                    group_cov,                    c=color,                    lw=1,                    marker=None,                    alpha=0.5)                axs[n].set_ylim(ymin, ymax)        axs[n].set_title(group, loc='center')        axs[n].axis('off')    # Plot peaks    n += 1    if pks.shape[0] > 0:                for pk_n,pk in pks.iterrows():                        axs[n].plot(range(pk.start, pk.end + 1, 1),                        np.zeros(pk.end - pk.start + 1),                        c='black',                        lw=8)                        axs[n].plot(range(pk.start, pk.end + 1, 1),                        np.zeros(pk.end - pk.start + 1),                        c='green' if pk.padj < p_thr else 'lightgray',                        lw=6)            axs[n].axis('off')        else:                axs[n].axis('off')    # Plot gene body    n += 1    intron_size = 1    axs[n].plot([struct.start.min(), struct.end.max() + 1],                [0, 0],                c='black',                lw=intron_size)    # Plot gene elements    utr_size = 5    exon_size = 8    for _,element in struct.iterrows():                if element.feature == 'exon':                        axs[n].plot([element.start, element.end + 1],                        [0, 0],                        c='black',                        lw=exon_size)        else:                        axs[n].plot([element.start, element.end + 1],                        [0, 0],                        c='black',                        lw=utr_size)    # Plot arrows indicating direction of gene    strand = struct.strand.values[0]    arrows_x = np.linspace(struct.start.min(), struct.end.max() + 1, 30)    if strand == '-' :                arrows_x = arrows_x[::-1]            #axs[n].plot(arrows_x,    #            np.zeros(arrows_x.shape[0]),    #            c='black',    #            lw=0,    #            marker='>' if strand == '+' else '<',    #            markersize=3)    #axs[n].plot(arrows_x,    #            np.zeros(arrows_x.shape[0]),    #            c='white',    #            lw=0,    #            marker='>' if strand == '+' else '<',    #            markersize=2)    axs[n].plot(arrows_x,                np.zeros(arrows_x.shape[0]),                c='black',                lw=0,                marker='4' if strand == '+' else '3',                markersize=8)    axs[n].axis('off')    plt.tight_layout()    plt.savefig(f'{gene}_averaged_profile.png', dpi=600)    plt.close()    ### ---------------------------------------- ###def plot_averaged_coverage_data_overlaid(gn, coords, struct, pks, covs, p_thr=0.05):        # Collapse groups to median values    for key in covs.keys():                covs[key] = np.median(covs[key], axis=0)        figsize = (10, 3)    height_ratios = [2, 0.55, 0.55]    xmin, xmax = coords[1:]    fig, axs = plt.subplots(nrows=3,                            ncols=1,                            figsize=figsize,                            height_ratios=height_ratios,                            sharex=True)    plt.xlim(xmin, xmax)    # Plot coverage for each group    group_colors = ['red', 'blue']    n = 0        for n_group, ((group, group_cov), color) in enumerate(zip(covs.items(), group_colors)):                axs[n].fill_between(x=np.arange(coords[1], coords[2] + 1, 1),                            y1=np.zeros(coords[2] - coords[1] + 1),                            y2=group_cov,                            color=color,                            alpha=0.5,                            lw=0)                #axs[n].plot(np.arange(coords[1], coords[2] + 1, 1),        #            group_cov,        #            c=color,        #            lw=1,        #            marker=None,        #            alpha=1)                #axs[n].set_title(group, loc='center')    axs[n].axis('off')    # Plot peaks    n += 1    if pks.shape[0] > 0:                for pk_n,pk in pks.iterrows():                        axs[n].plot(range(pk.start, pk.end + 1, 1),                        np.zeros(pk.end - pk.start + 1),                        c='black',                        lw=8)                        axs[n].plot(range(pk.start, pk.end + 1, 1),                        np.zeros(pk.end - pk.start + 1),                        c='green' if pk.padj < p_thr else 'lightgray',                        lw=6)            axs[n].axis('off')        else:                axs[n].axis('off')    # Plot gene body    n += 1    intron_size = 1    axs[n].plot([struct.start.min(), struct.end.max() + 1],                [0, 0],                c='black',                lw=intron_size)    # Plot gene elements    utr_size = 5    exon_size = 8    for _,element in struct.iterrows():                if element.feature == 'exon':                        axs[n].plot([element.start, element.end + 1],                        [0, 0],                        c='black',                        lw=exon_size)        else:                        axs[n].plot([element.start, element.end + 1],                        [0, 0],                        c='black',                        lw=utr_size)    # Plot arrows indicating direction of gene    strand = struct.strand.values[0]    arrows_x = np.linspace(struct.start.min(), struct.end.max() + 1, 30)    if strand == '-' :                arrows_x = arrows_x[::-1]            #axs[n].plot(arrows_x,    #            np.zeros(arrows_x.shape[0]),    #            c='black',    #            lw=0,    #            marker='>' if strand == '+' else '<',    #            markersize=3)    #axs[n].plot(arrows_x,    #            np.zeros(arrows_x.shape[0]),    #            c='white',    #            lw=0,    #            marker='>' if strand == '+' else '<',    #            markersize=2)    axs[n].plot(arrows_x,                np.zeros(arrows_x.shape[0]),                c='black',                lw=0,                marker='4' if strand == '+' else '3',                markersize=8)    axs[n].axis('off')    plt.tight_layout()    plt.savefig(f'{gene}_averaged_profile_overlaid.png', dpi=600)    plt.close()    ### ------------------MAIN------------------ ###import numpy as npimport pandas as pdfrom matplotlib import pyplot as pltfrom sys import argv### Parse data manifestannotation_path, peaks_path, samples_path, genes_list, gene_extension, p_thr = parse_args()### Load gtf and peaks filesgtf = pd.read_csv(annotation_path, sep='\t', header=None, comment='#')gtf.columns = ['chrom', 'source', 'feature', 'start', 'end', 'score', 'strand', 'frame', 'attributes']peaks = pd.read_csv(peaks_path, sep='\t', header=0)peaks_of_interest = peaks.loc[(peaks.GeneName.isin(genes_list)) & (peaks.padj < p_thr),]peaks_of_interest.to_csv('genes_of_interest_peaks.tsv', index=False, sep='\t')### Plot genesfor gene in genes_list:        # Extract gene structure    gene_coords, gene_structure = get_gene_structure(gtf, gene)        # Extract peaks in gene region    gene_peaks = peaks.loc[((peaks.GeneID == gene) |                            (peaks.GeneName == gene)) &                           (peaks.padj < p_thr), ['Chr', 'Start', 'End', 'log2FoldChange', 'padj']]    #gene_peaks = peaks.loc[(peaks.GeneID == gene) |    #                        (peaks.GeneName == gene), ['Chr', 'Start', 'End', 'log2FoldChange', 'padj']]    gene_peaks.columns = ['chrom', 'start', 'end', 'log2FoldChange', 'padj']        # Update plotting region coords    if gene_peaks.start.min() < gene_coords[1]:                gene_coords[1] = gene_peaks.start.min()        if gene_peaks.end.max() > gene_coords[2]:                gene_coords[2] = gene_peaks.end.max()        # Extend region    gene_coords[1] -= gene_extension    gene_coords[2] += gene_extension        # Extract coverage in gene region    gene_coverages = get_gene_coverage(gene_coords, samples_path)        # Plot    plot_individual_coverage_data(gene, gene_coords, gene_structure, gene_peaks, gene_coverages.copy(), p_thr)    plot_averaged_coverage_data(gene, gene_coords, gene_structure, gene_peaks, gene_coverages.copy(), p_thr)    plot_averaged_coverage_data_overlaid(gene, gene_coords, gene_structure, gene_peaks, gene_coverages.copy(), p_thr)